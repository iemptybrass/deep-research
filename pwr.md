
# Advanced Laptop CPU Power-Saving Strategies (Intel, AMD, ARM)

Modern laptops offer numerous knobs for power management, spanning CPU features, kernel settings, and hardware configurations. This report analyzes advanced power-saving techniques across **Intel**, **AMD**, and **ARM** architectures – including disabling hyper-threading/SMT, offloading tasks, CPU frequency policies, undervolting, downclocking, and deep kernel tuning – and evaluates the power savings versus performance trade-offs. We focus on Linux-specific methods (with notes on NixOS module settings), covering CPU frequency scaling, idle state tuning, PCIe ASPM, and tools like TLP, `powertop`, and `cpupower`. We also examine how memory (RAM) configuration (e.g. LPDDR vs DDR, unused banks, RAM speed) impacts power consumption and whether CPU work can be reduced via RAM optimizations. Technical references and community findings are provided throughout.

## CPU Architecture-Specific Techniques

Each CPU architecture has unique features for balancing performance and power. Below we detail strategies for Intel and AMD x86 processors and for ARM-based CPUs, highlighting their effects and trade-offs.

### Intel CPUs (x86 Architecture)

- **Disabling Hyper-Threading (HT):** Intel’s Hyper-Threading (two threads per core) can be turned off to save power. In *theory*, idle power is mostly unaffected since physical cores remain active. However, under load, fewer concurrent threads reduce power draw (at the cost of throughput). Community tests show HT off can lower CPU package power by ~16% in heavy multithreaded loads ([Can Disabling Hyperthreading Increase Battery Life? - CPUs, Motherboards, and Memory - Linus Tech Tips](https://linustechtips.com/topic/694423-can-disabling-hyperthreading-increase-battery-life/#:~:text=While%20running%20Cinebench%3A)). In one experiment, a laptop drew ~52 W in Cinebench with HT off vs ~62 W with HT on ([Can Disabling Hyperthreading Increase Battery Life? - CPUs, Motherboards, and Memory - Linus Tech Tips](https://linustechtips.com/topic/694423-can-disabling-hyperthreading-increase-battery-life/#:~:text=While%20running%20Cinebench%3A)). Surprisingly, that user also saw much lower idle discharge (14 W vs 28 W) with HT off ([Can Disabling Hyperthreading Increase Battery Life? - CPUs, Motherboards, and Memory - Linus Tech Tips](https://linustechtips.com/topic/694423-can-disabling-hyperthreading-increase-battery-life/#:~:text=Without%20Hyperthreading%2C%20the%20battery%20discharge,stayed%20right%20around%2052%20watts)), suggesting HT might prevent the deepest idle states or introduce background overhead. Generally, disabling HT yields a small power savings when cores would have been fully utilized, but it *does* reduce performance for multithreaded tasks (roughly up to 20-30% in CPU-bound apps). For mostly single-threaded workloads or thermal-limited scenarios, turning off HT can slightly improve efficiency (and reduce heat), as the single thread can boost higher without a second thread generating heat on the same core ([HOW TO ENABLE BIOS ADVANCED SETTINGS ON NITRO 5 AN515-44? — Acer Community](https://community.acer.com/en/discussion/676399/how-to-enable-bios-advanced-settings-on-nitro-5-an515-44#:~:text=via%20the%20Thread%20Balancing,while%20seeing%20similar%20Power%20Consumption)) ([HOW TO ENABLE BIOS ADVANCED SETTINGS ON NITRO 5 AN515-44? — Acer Community](https://community.acer.com/en/discussion/676399/how-to-enable-bios-advanced-settings-on-nitro-5-an515-44#:~:text=Consumption)). The trade-off is lost “free” throughput on multi-core workloads. Enabling HT usually is beneficial because when extra threads aren’t needed, they don’t consume much power, and when they are needed, performance is higher – essentially *performance gain when utilized, and negligible cost when idle*, aside from edge cases ([HOW TO ENABLE BIOS ADVANCED SETTINGS ON NITRO 5 AN515-44? — Acer Community](https://community.acer.com/en/discussion/676399/how-to-enable-bios-advanced-settings-on-nitro-5-an515-44#:~:text=Consumption)).

- **CPU Frequency Scaling & Governors:** Intel platforms use the `intel_pstate` scaling driver on newer kernels, which manages P-states (performance states) with an internal governor (with modes like “powersave” and “performance”). By default, `intel_pstate` may run in **active** mode using hardware-controlled frequency (HWP) on newer CPUs, or in passive mode (alias `intel_cpufreq`) on older models. Adjusting the CPU scaling governor has direct impact on power/performance. For example, setting the governor to `powersave` (or using a low **Energy Performance Preference** on HWP) will bias the CPU toward lower frequencies, saving power at the cost of peak performance. Tuning can be dynamic: many Linux users use **`cpupower`** or tools like TLP to set **“powersave” on battery** and **“performance” on AC**. Intel CPUs also support **Turbo Boost**; disabling turbo (e.g. via TLP `CPU_MAX_PERF_ON_BAT=** x` or `intel_pstate=no_turbo` param) caps the max frequency, significantly reducing power spikes at the cost of peak performance. Setting a lower max frequency (downclocking) is an effective way to limit power: for instance, capping at 70-80% of max frequency can reduce voltage and power quadratically, yielding big battery gains in exchange for some performance. In practice, using the `powersave` governor or limiting CPU perf to e.g. 20% on battery can cut CPU power draw heavily under load, but interactive performance will suffer if demanding tasks occur. On idle, the governor has less impact since modern CPUs drop to low frequencies anyway when idle (idle power is dominated by C-states, not P-states).

- **Undervolting (Voltage Reduction):** **Undervolting** is reducing CPU core voltage while maintaining stock frequencies. This lowers active power quadratically (Power ∝ V²) and reduces heat output *without* reducing performance (if stable) ([Linux Laptop Optimizations  · GitHub](https://gist.github.com/LarryIsBetter/218fda4358565c431ba0e831665af3d1?permalink_comment_id=4739484#:~:text=%2A%20From%20Arch%20Wiki%20,I%27ll%20leave%20a%20link%20to)). On Intel laptops, undervolting has historically been a major tuning method: users achieved ~-50 to -150 mV core voltage offset, often yielding ~10–20% less power in heavy load and cooler operation. In fact, on laptops that throttle due to power or thermal limits, undervolting can *increase* performance by preventing throttling ([Does undervolting cause performance loss? | TechPowerUp Forums](https://www.techpowerup.com/forums/threads/does-undervolting-cause-performance-loss.283238/#:~:text=Forums%20www,thermal%20throttling%20%3D%20increased%20performance)). It’s a “free” efficiency gain – lower voltage for the same work – until stability limits are hit. **Trade-offs:** if undervolted too far, system instability (crashes) occurs, so finding the safe margin is key. Unfortunately, as of late-2019, Intel locked voltage control on many CPUs via BIOS/firmware updates (to mitigate the Plundervolt vulnerability) ([Linux Laptop Optimizations  · GitHub](https://gist.github.com/LarryIsBetter/218fda4358565c431ba0e831665af3d1?permalink_comment_id=4739484#:~:text=Note%20that%20most%20desktop%20motherboards,to%20undervolt%20your%20AMD%20CPU)). Many 10th-gen and newer Intel CPUs cannot be undervolted in software ([Linux Laptop Optimizations  · GitHub](https://gist.github.com/LarryIsBetter/218fda4358565c431ba0e831665af3d1?permalink_comment_id=4739484#:~:text=Note%20that%20most%20desktop%20motherboards,to%20undervolt%20your%20AMD%20CPU)), although some high-performance laptops still allow it in BIOS. On older Intel systems or unlocked ones, tools like **`intel-undervolt`** on Linux can apply offsets at boot (requires enabling MSR writes ([Linux Laptop Optimizations  · GitHub](https://gist.github.com/LarryIsBetter/218fda4358565c431ba0e831665af3d1?permalink_comment_id=4739484#:~:text=run%20sudo%20pacman%20))). When possible, undervolting is highly recommended for power users: it reduces CPU package power and extends battery life without explicit performance loss ([Does undervolting cause performance loss? | TechPowerUp Forums](https://www.techpowerup.com/forums/threads/does-undervolting-cause-performance-loss.283238/#:~:text=Forums%20www,thermal%20throttling%20%3D%20increased%20performance)). For example, a modest ~0.1 V undervolt might save several watts under load and drop CPU temperatures by ~5-10°C, which can indirectly allow higher sustained clocks (improving performance) ([Does undervolting cause performance loss? | TechPowerUp Forums](https://www.techpowerup.com/forums/threads/does-undervolting-cause-performance-loss.283238/#:~:text=Forums%20www,thermal%20throttling%20%3D%20increased%20performance)). Always stress-test after undervolting to ensure stability ([Linux Laptop Optimizations  · GitHub](https://gist.github.com/LarryIsBetter/218fda4358565c431ba0e831665af3d1?permalink_comment_id=4739484#:~:text=Next%20stress%20you%27ll%20test%20for,bin)).

- **Downclocking & Disabling Turbo:** Manually downclocking (reducing max frequency) or disabling turbo boost are straightforward ways to reduce power. Unlike undervolting, these *do* trade performance for power savings. For Intel, one can set a lower max P-state or use `CPU_MAX_PERF_ON_BAT` in TLP (as shown in the NixOS example, limiting to 20% on battery). This might lock the CPU at a much lower GHz. The benefit is a hard cap on power draw – the CPU will run cooler and use less battery during intensive tasks. The downside is slower completion of tasks. Interestingly, a *partial* downclock (e.g. capping at base frequency or slightly above) can be efficient: it prevents the inefficient high-voltage turbo region, so you lose peak performance but often the performance per watt improves. Another tactic is using Intel’s **TDP-down modes**: some Intel chips support configurable TDP – e.g. a 15 W CPU can be set to 10 W – which effectively downclocks and lowers voltage. Many ultrabooks have “Quiet” or “Battery Saver” modes that do this internally. Ultimately, downclocking is a coarse but effective lever: performance loss is proportional to frequency drop, but power savings can be nonlinear (biggest savings when avoiding high turbo voltage levels). Users can also experiment with Intel’s **energy_perf_bias** setting (via `x86_energy_perf_policy` or sysfs), which ranges from “performance” to “power”. On battery, setting this bias to “power” can encourage the CPU to favor lower frequencies more aggressively.

- **Idle State Tuning (C-states):** Intel CPUs have deep idle states (C-states C1…C10 on modern chips) that drastically cut power when the CPU is idle. Deeper C-states save more power but incur longer wake-up latency. By default, the CPU and OS (using the **`intel_idle`** driver or ACPI `cpuidle`) manage this automatically. In Linux, the **CPUIdle governor** (usually the “menu” governor) tries to predict idle duration and select an appropriate C-state. On Intel, typically package C8/C9/C10 states provide huge power savings at idle (CPU package dropping to milliwatts). Ensuring the system can reach these states is crucial for good battery life. BIOS/firmware sometimes can limit C-states (for stability with certain devices). If an Intel CPU isn’t entering deep C-states, idle power consumption can be much higher. Tools like `powertop` show C-state residency. Advanced users can tune or restrict C-states via kernel parameters (e.g. `intel_idle.max_cstate=N` or `processor.max_cstate=N` for ACPI driver) – but generally, you *want* the deepest C-state available on battery. Only in specific cases (like real-time audio or older hardware with buggy deep states) would one disable deep C-states. Another corner case is **Core Parking**: Windows will park idle cores, but on Linux the scheduler might still ping all cores occasionally. Disabling HT as mentioned or using the **`idle=nomwait`** parameter (for some AMD issues) can help allow deeper package C-states. In summary, Intel’s idle power management is highly effective by default; the main “tuning” is to avoid anything that prevents idle entry (misbehaving drivers, periodic timers). When working properly, the CPU should spend most idle time in package C10 (on newer Intel), drawing minimal power. If not, forcing certain settings or updating firmware can sometimes help.

### AMD CPUs (x86 Architecture)

- **Disabling SMT (Simultaneous Multi-Threading):** AMD’s SMT is analogous to Intel’s HT – each core can run two threads. The considerations for power vs performance are similar. By turning off SMT, you remove the additional thread on each core. AMD official guidance generally suggests keeping SMT on: when workloads can use it, it provides extra performance “for free”; when unused, it has negligible power cost ([HOW TO ENABLE BIOS ADVANCED SETTINGS ON NITRO 5 AN515-44? — Acer Community](https://community.acer.com/en/discussion/676399/how-to-enable-bios-advanced-settings-on-nitro-5-an515-44#:~:text=Consumption)). In other words, SMT *on* gives either increased throughput or improved efficiency (if a single thread can occupy the core’s resources more fully) ([HOW TO ENABLE BIOS ADVANCED SETTINGS ON NITRO 5 AN515-44? — Acer Community](https://community.acer.com/en/discussion/676399/how-to-enable-bios-advanced-settings-on-nitro-5-an515-44#:~:text=Consumption)). Some users report that disabling SMT can reduce power usage in certain scenarios or reduce temperature because the core isn’t handling two heavy threads at once. For example, an AMD user noted you might see *lower* clocks but also lower temps with SMT on, since AMD’s Precision Boost will spread work across threads and manage power ([HOW TO ENABLE BIOS ADVANCED SETTINGS ON NITRO 5 AN515-44? — Acer Community](https://community.acer.com/en/discussion/676399/how-to-enable-bios-advanced-settings-on-nitro-5-an515-44#:~:text=SMT%20however%20doesn%27t%20work%20like,ALG%20Pipeline)). Another community member explains: with SMT off, a single thread may run at higher clock (more voltage) to use the core, possibly *increasing* temperature per thread, whereas SMT on balances the core’s execution units and can actually lead to slightly *lower* per-thread clocks but higher total throughput ([HOW TO ENABLE BIOS ADVANCED SETTINGS ON NITRO 5 AN515-44? — Acer Community](https://community.acer.com/en/discussion/676399/how-to-enable-bios-advanced-settings-on-nitro-5-an515-44#:~:text=SMT%20however%20doesn%27t%20work%20like,ALG%20Pipeline)). Net effect: **SMT off** could marginally improve power efficiency if your workload doesn’t scale to extra threads (the second thread just adds overhead), but often the difference is small. If you truly want to save power on an AMD CPU, a better approach is capping frequencies or disabling *physical* cores (which some BIOS allow) – cutting cores will linearly drop power, albeit at heavy multi-core performance expense. In summary, disabling SMT on AMD is usually not worthwhile for general use; it may help thermals in edge cases or specific games that misbehave with SMT, but broadly, AMD’s SMT on unused cores doesn’t hurt power much. The *trade-off* (losing multi-thread performance) typically outweighs the minor idle or single-thread efficiency gain.

- **CPU Frequency Scaling (amd-pstate vs acpi_cpufreq):** Recent AMD Ryzen CPUs introduced a new Linux driver called **`amd_pstate`**, which allows finer control of frequencies and works with AMD’s Collaborative Performance Control. As of Linux 6.5+, `amd_pstate` in **active mode** is used by default on Zen2 and newer CPUs. This driver, like Intel’s, has an internal governor and can leverage an “Energy Preference” (EPP) for balance between performance and efficiency. Older AMD or if `amd_pstate` is not enabled will use `acpi_cpufreq` (via ACPI CPPC on Ryzen), which tends to expose only a few P-states on some models. Tuning AMD CPU frequency works similarly to Intel: you can set governors (`schedutil`, `ondemand`, etc.) or limits via `cpupower`. By default AMD on Linux often uses `ondemand` or `schedutil` which ramp frequency based on load. For better battery life, forcing the `powersave` governor or limiting max freq helps. AMD’s Boost (Precision Boost) can be curbed by setting a lower TDP or using BIOS options like “Eco Mode” on Ryzen (which can turn a 45W chip into e.g. 35W). Some laptops expose a “STAPM” or cTDP setting via ACPI for this. **Trade-offs:** Aggressive frequency scaling to lower clocks will save energy but can make the system feel slower on bursty tasks. The new `amd_pstate` with EPP allows a gradient approach – e.g. you can echo a higher EPP value (energy efficient bias) to sysfs to favor lower power at slight performance cost. AMD’s frequency response and efficiency are generally similar to Intel: staying at low clocks yields big power savings for idle/light loads, but heavy tasks will downclock proportionally slow their completion.

- **Undervolting and PBO Tuning:** Undervolting on AMD is a bit less straightforward than on older Intel chips. Many AMD Ryzen CPUs (especially mobile) do not expose voltage control to the OS for security reasons. Desktop Ryzen allows undervolting via the BIOS (Curve Optimizer in Precision Boost Overdrive, which can apply a negative voltage offset per core). On laptops, BIOS options are often limited, but some enthusiasts use tools (Windows “RyzenAdj” or SMU commands) to adjust power limits. The Arch Wiki notes a method for undervolting certain AMD CPUs (K10 and newer) exists ([Linux Laptop Optimizations  · GitHub](https://gist.github.com/LarryIsBetter/218fda4358565c431ba0e831665af3d1?permalink_comment_id=4739484#:~:text=%2A%20From%20Arch%20Wiki%20,to%20undervolt%20your%20AMD%20CPU)), likely referring to a kernel patch or third-party utility, but it’s not trivial. As a safer route, AMD users can use **PBO undervolt (Curve)** if available: for example, a negative curve of -10 or -20 can shave off voltage, reducing power draw for a given frequency. Another approach is using “Eco Mode” or a lower PPT (package power tracking) limit – effectively an undervolt/underclock that the CPU firmware handles to stay in a lower power envelope. **Trade-off:** a stable undervolt yields only benefits (less power, same performance), but going too far causes instability. Since it’s hard to do in software on most laptops, many AMD users opt to simply cap the boost: disabling “Boost Mode” (some firmware have a toggle) will keep the CPU at base frequency and dramatically cut power usage and temps, albeit with a performance hit on peak loads. For example, a Ryzen laptop CPU at 3.0 GHz max will run much cooler than boosting to 4+ GHz, and often the performance loss in everyday tasks is small while battery life improves.

- **Idle States and ACPI Tuning:** AMD’s idle behavior on modern Linux uses ACPI CPPC combined with either the `intel_idle` equivalent for AMD (called `acpi_idle` driver) or hints from firmware. AMD CPUs support deep C-states (often Cn states that equate to low-power idle). One known issue on some Ryzen laptops was the need for the kernel parameter `idle=nomwait` – this was to workaround a bug where the CPU would not enter deeper idle due to a firmware timing issue. In general, ensuring **“Global C-state control”** is enabled (in BIOS, if exposed) allows the CPU to drop cores and package into low-power states on idle. Linux will handle this, and tools like `powertop` can confirm package c-state residency. If an AMD laptop is drawing higher idle power, one might check for devices preventing deeper idle (e.g. ASPM off on PCI, or a USB device constantly waking system). Custom ACPI tables (DSDT overrides) are an extreme measure, but some power users have patched DSDTs to fix buggy ACPI implementations that keep the CPU from idling properly. For instance, adding missing _PSD/_CST entries or enabling ASPM via ACPI could be done by recompiling a DSDT and overriding it at boot. This is complex, but it highlights that some power optimizations (like PCIe ASPM or clock gating) sometimes hinge on ACPI settings from the OEM. **Trade-off:** Idle state tuning usually has minimal performance impact (it only affects how quickly the CPU can wake – usually microseconds differences). Unless one is dealing with latency-critical workloads, you want the deepest C-state available on AMD as well. If latency is a concern, you might limit to C1 or C2, sacrificing battery life.

### ARM CPUs (ARM Architecture)

ARM-based laptop and mobile CPUs (found in devices from Android tablets/phones to Apple Silicon Macs and some Windows laptops) inherently prioritize energy efficiency. Their power-saving strategies revolve around dynamically adjusting to workload using architecture features and OS scheduling:

- **big.LITTLE and Core Offlining:** Many ARM SoCs use a heterogeneous design (e.g. 4 big cores + 4 small cores). For power savings, the OS (with an **Energy-Aware Scheduler**) tries to run background or low-load tasks on the small, high-efficiency cores, reserving big cores for heavy work. In Linux, this is facilitated by scheduling heuristics and CPU affinity tuning. For example, on an ARM laptop with big.LITTLE, one could *offline* (turn off) the big cores entirely when only light tasks are running, forcing all work onto little cores (drastically reducing power at a significant performance cost for any heavier tasks). Some tools or scripts on Android (and kernels like IntelliPlug) historically did core switching – essentially disabling fast cores when not needed. **Trade-off:** Disabling high-performance cores yields major power savings (small cores use far less power) but obviously caps performance. A dynamic approach is preferable: let the scheduler migrate tasks – this way, when a burst of performance is needed, a big core can briefly wake and then go back idle. ARM’s architecture supports very rapid power gating of cores, so idle cores can be power-gated with minimal overhead. Thus, unlike x86 where all cores are usually active (just in deep C-states), on ARM it’s common for entire clusters to shut off. Modern smartphone SoCs even turn off clusters or put whole system into deep sleep states (SoC suspend) aggressively. On Linux, **`cpufreq` governors** per cluster can be tuned such that the big cluster stays at lowest freq or off on battery.

- **CPU Frequency Scaling on ARM:** ARM systems typically use the generic `cpufreq` drivers (often via `scaling_available_frequencies` exposed by SoC-specific drivers). Governors like `ondemand` or `schedutil` manage the DVFS (Dynamic Voltage and Frequency Scaling) for each cluster. Many ARM SoCs have hardware DVFS helpers as well. Tuning the governor to a more conservative profile can save power – e.g., using `powersave` governor on an ARM Cortex-A CPUs will lock them at the lowest clock. In practice, most ARM laptops/desktops (like Raspberry Pi, PineBook, etc.) run at lower GHz and can be downclocked further if desired. For instance, if an ARM board runs at 2.0 GHz max, capping it to 1.5 GHz can reduce voltage and extend battery. ARM also allows **setting per-core max frequencies** or even disabling cores, via sysfs (`/sys/devices/system/cpu/cpu*/online`). For extreme power saving on a quad-core ARM, one might turn off 2 cores entirely and limit the freq of the rest. The performance hit is obvious (fewer cores, slower clock), but it can be viable for say an always-on device where battery life is paramount and performance needs are minimal. Generally, ARM chips are so optimized for efficiency that their idle power is often extremely low by default – so frequency scaling matters primarily under load.

- **Undervolting ARM:** Undervolting is less common on ARM mobile chips because they are already tightly binned for low power. Some enthusiast phone kernels exposed undervolting interfaces (e.g. to undervolt Qualcomm Snapdragon cores via kernel modules), but on laptops with ARM (like Apple M1/M2 or Snapdragon HCX), these options are usually locked down. Apple’s M1, for example, does not allow user voltage/frequency control – Apple’s power management automatically adjusts frequencies based on workload and power constraints, achieving very low power usage (the M1 can run under 1 W on light tasks). Thus, users have limited manual undervolt ability on most ARM systems. The best one can do is ensure the *governor mode* is in a battery-optimized setting (on Linux, perhaps use `schedutil` with energy bias, or limit turbo states if any). Another aspect is **memory and interconnect frequency scaling**: ARM SoCs often scale the DRAM controller and GPU frequency. Lowering display resolution or frame rate, for example, lowers GPU load, which keeps the memory controller in power-save mode more often – indirectly saving CPU power as well by reducing work.

- **Idle and Deep Sleep (Suspend to RAM vs Suspend to Idle):** ARM systems heavily utilize deep idle. For instance, on a phone, when the screen is off, the OS will enter an SoC suspend where nearly everything shuts down except a tiny power domain to listen for wake events. Laptops with ARM (like Windows on ARM devices) may use ACPI S0ix (connected standby). Linux on ARM typically uses the suspend-to-RAM state (which on ARM is just CPU off, RAM self-refresh). Device Tree can describe wakeup-capable devices; by dynamically manipulating the device tree or using runtime power management, one can disable unused devices to save power. **Dynamic Device Tree manipulation** is an advanced concept where the OS inserts or removes device nodes at runtime (or applies overlays) – e.g., to disable a component. This is not commonly done for CPU power management specifically, but in principle, one could remove a node for an unused IP block to have the kernel turn it off. More practically, runtime power management (auto-suspend) handles this without manual device tree changes. **Custom ACPI tables** are more relevant on x86, but on some ARM Windows laptops, ACPI is used; a custom ACPI might be needed to enable certain power features in Linux (a niche scenario). For most ARM Linux devices, the provided device tree and drivers already aim for maximum power savings.

In summary, **ARM’s power-saving trade-offs** often involve sacrificing peak performance or reducing active cores. However, because ARM designs are geared for efficiency, many of these techniques have modest returns compared to x86. An ARM laptop running a low-intensity workload might already only draw a couple of watts. Still, aggressive tuning (disabling big cores, lowering frequencies) can extend battery life further at the cost of responsiveness and max throughput. The Linux kernel’s energy-aware scheduling, when enabled (`CONFIG_SCHED_ESTIMATED_EFFICIENCY` and using schedutil governor), already does a good job of balancing performance and power on heterogenous ARM systems.

### **Comparison of Power-Saving Techniques by CPU Architecture**

To summarize the architecture-specific options, the table below compares key techniques for Intel, AMD, and ARM, with notes on power savings and performance impact:

| **Technique**                 | **Intel (x86)**                                         | **AMD (x86)**                                          | **ARM (ARM64)**                                           |
|------------------------------|---------------------------------------------------------|--------------------------------------------------------|-----------------------------------------------------------|
| **Disable Hyper-Threading / SMT** | Possible via BIOS or OS (`/sys/devices/system/cpu/smt/control`). Saves some power under full load (e.g. ~10–15% less package power) ([Can Disabling Hyperthreading Increase Battery Life? - CPUs, Motherboards, and Memory - Linus Tech Tips](https://linustechtips.com/topic/694423-can-disabling-hyperthreading-increase-battery-life/#:~:text=While%20running%20Cinebench%3A)). Idle impact minimal (logical cores idle when not in use). Loses up to 30% multithread performance in highly threaded tasks. | Possible via BIOS on some systems (consumer laptops often lock SMT on). Slight efficiency gain if workload doesn’t use extra threads. Generally recommended **ON**: “when SMT isn’t leveraged, you get more efficient power usage; when it is, you get free performance” ([HOW TO ENABLE BIOS ADVANCED SETTINGS ON NITRO 5 AN515-44? — Acer Community](https://community.acer.com/en/discussion/676399/how-to-enable-bios-advanced-settings-on-nitro-5-an515-44#:~:text=Consumption)). Idle power difference is negligible in most cases. | Most ARM cores lack SMT (except some high-end ARM server cores). Typically not applicable. ARM focuses on turning off whole cores rather than threading. |
| **CPU Frequency Governor Policies** | Uses **`intel_pstate`** driver on modern systems. Governors: “performance” (max speed) vs “powersave” (more conservative) or `schedutil` (load-based). On battery, using “powersave” or setting an Energy-Perf bias to “power” saves energy at cost of performance. Can also disable Turbo Boost to cap frequency. Trade-off: lower performance especially for bursty tasks, but smoother thermal behavior and longer battery. | Uses **`amd_pstate`** (Zen2+ Linux 6.5+) or ACPI `cpufreq`. Governors behave similarly (ondemand/schedutil common). Can also set a fixed lower max perf% on battery (via TLP or `cpupower`). AMD’s Precision Boost will honor power limits; e.g. setting a 25W limit on a 35W CPU will reduce clocks. Trade-off: minor responsiveness loss on “powersave” governor, and capped top speeds if limiting frequency. | Uses standard cpufreq governors per cluster. Often uses `schedutil` with EAS for big.LITTLE. Can force little cores for tasks to save power. Governors on ARM are usually set for quick ramp-up (to keep UI smooth), but setting them to conservative can extend battery. Trade-off: potentially sluggish performance if too low frequency, but significant power savings in sustained workloads. |
| **Undervolting**             | Supported on older Intel (pre-10th gen) via tools (XTU on Windows, `intel-undervolt` on Linux) ([Linux Laptop Optimizations  · GitHub](https://gist.github.com/LarryIsBetter/218fda4358565c431ba0e831665af3d1?permalink_comment_id=4739484#:~:text=%2A%20From%20Arch%20Wiki%20,I%27ll%20leave%20a%20link%20to)). Reduces power/heat ~ linear with voltage drop (no performance loss unless unstable). Newer Intel locked undervolt due to security ([Linux Laptop Optimizations  · GitHub](https://gist.github.com/LarryIsBetter/218fda4358565c431ba0e831665af3d1?permalink_comment_id=4739484#:~:text=Note%20that%20most%20desktop%20motherboards,to%20undervolt%20your%20AMD%20CPU)). When available, it’s a top method for efficiency – e.g. a –100 mV undervolt often yields >10% power reduction under load with zero performance hit ([Does undervolting cause performance loss? | TechPowerUp Forums](https://www.techpowerup.com/forums/threads/does-undervolting-cause-performance-loss.283238/#:~:text=Forums%20www,thermal%20throttling%20%3D%20increased%20performance)). Must stability test. | Not easily exposed in software; mostly via BIOS (Curve Optimizer). Some Linux patches exist for K10+ CPUs undervolt ([Linux Laptop Optimizations  · GitHub](https://gist.github.com/LarryIsBetter/218fda4358565c431ba0e831665af3d1?permalink_comment_id=4739484#:~:text=%2A%20From%20Arch%20Wiki%20,to%20undervolt%20your%20AMD%20CPU)) but not mainstream. Users can effectively undervolt by using PBO negative curve or by lowering PPT (power limit). This achieves a similar end (less voltage used at a given frequency). Gains: lower power and temps, possibly avoiding throttle. No performance loss unless hitting new lower limits. | Generally **not user-accessible**. ARM SoCs auto-manage voltage-frequency curves. Enthusiast kernels on phones sometimes allowed slight undervolt, but on laptops (e.g. Apple M1) there is no interface. These chips are highly optimized at stock voltage for efficiency. Any undervolting would have to come from manufacturer firmware. Thus, not a typical user strategy on ARM. |
| **Downclocking / Frequency Capping** | Simple to do (set lower max freq via `cpupower` or TLP). Prevents high turbo power draw. Saves substantial power under load – e.g. capping at 70% freq can cut CPU power by 2× or more for heavy tasks (since power scales ~f²V²). At idle, no big effect. Trade-off: tasks take longer; heavy CPU work might run at half speed. Good for extending battery when performance is secondary. | Also simple via `cpupower` or Ryzen power limits. AMD mobile CPUs often have multiple power modes; using the lowest will downclock. For example, a Ryzen 4900HS at 10W will stay at ~1.4 GHz instead of 4 GHz – huge power drop, performance vastly reduced in CPU-heavy apps. For everyday light use, capping boost (or disabling boost entirely) yields a cooler, quieter laptop with only occasional slowdowns. | Often achieved by forcing use of small cores or setting low max freq on all cores. Many ARM devices already run relatively low clocks to save power. E.g. an ARM Chromebook might run 2.0 GHz max; user could cap to 1.0 GHz to double battery life for light tasks that are not CPU-bound. Performance on any CPU-heavy task will degrade linearly with frequency cap. ARM’s DVFS usually optimizes this anyway (idling at low freq). |
| **Idle State (C-State) Tuning**   | Intel has deep C-states (C7-C10) that drop idle power to near-zero. Usually no need to tweak aside from ensuring nothing blocks them. One can use `powertop` to verify residency. Kernel param `intel_idle.max_cstate` can limit depth (useful only if deep states cause issues). Limiting to shallow C-states (C1/C2) keeps CPU ready to wake faster but burns more idle power – not recommended on battery (could raise idle draw from ~0.5 W to several W). | AMD also supports deep package C-states (package C6, etc.). AMD’s power management might require BIOS settings (“CPU C6 Support” etc. enabled). Typically works out of the box; if not, kernel param `idle=nomwait` or BIOS updates may be needed. Tuning C-states is usually about *allowing* deeper ones for max savings. Like Intel, disabling deep idle (for latency reasons) will hurt battery life. Leave idle handling to OS for best results. | ARM idle states are managed by PSCI or firmware – cores go offline or into retention. On Linux, not much manual control; the SoC will enter its low-power modes automatically when idle. One can ensure unnecessary background tasks are minimized so the SoC can stay in deep idle. The concept of C-states is abstracted, but e.g. ARM can put cores in WFI (Wait-For-Interrupt) which is akin to C1, and deeper power-down of cores like C2/C3. Tuning mainly involves disabling any periodic timers that prevent deep sleep. Generally, ARM achieves great idle efficiency without user intervention. |

*Table: Key power-saving techniques by architecture, with their typical impact. Intel/AMD share many similar approaches (different names, same concepts), while ARM’s approach differs due to heterogenous cores and firmware-managed DVFS.* ([Can Disabling Hyperthreading Increase Battery Life? - CPUs, Motherboards, and Memory - Linus Tech Tips](https://linustechtips.com/topic/694423-can-disabling-hyperthreading-increase-battery-life/#:~:text=Without%20Hyperthreading%2C%20the%20battery%20discharge,stayed%20right%20around%2052%20watts)) ([HOW TO ENABLE BIOS ADVANCED SETTINGS ON NITRO 5 AN515-44? — Acer Community](https://community.acer.com/en/discussion/676399/how-to-enable-bios-advanced-settings-on-nitro-5-an515-44#:~:text=Consumption)) ([Linux Laptop Optimizations  · GitHub](https://gist.github.com/LarryIsBetter/218fda4358565c431ba0e831665af3d1?permalink_comment_id=4739484#:~:text=%2A%20From%20Arch%20Wiki%20,I%27ll%20leave%20a%20link%20to))

## Linux Kernel-Level Power Management Techniques

Regardless of CPU brand, the Linux kernel provides a rich set of power management features that can be tuned. These include CPU frequency governors, scheduler settings, device power management (PCIe ASPM, USB autosuspend, SATA link power management), and various kernel modules/options. Below, we explore these along with tools and configuration methods (including NixOS-specific tips).

### CPU Frequency Scaling and Governors

Linux’s **CPUFreq subsystem** handles dynamic frequency scaling. It consists of **scaling drivers** (interface to hardware, e.g. `intel_pstate`, `acpi_cpufreq`, `amd_pstate`, etc.) and **scaling governors** (algorithms to choose frequency based on load). By default, modern kernels often choose a sensible driver and governor automatically. Key points:

- **Scaling Drivers:** On Intel, `intel_pstate` is used by default for Sandy Bridge and newer CPUs. It bypasses ACPI and directly controls P-states, leveraging hardware P-state control on newer chips. On AMD, as noted, new Zen CPUs use `amd_pstate` (if supported by kernel); otherwise the generic `acpi_cpufreq` (which on Ryzen has limitations – only a few discrete frequencies). ARM platforms usually have platform-specific cpufreq drivers or use ACPI CPPC on server-class ARM. You generally don’t manually change drivers, except via kernel parameters: e.g. `intel_pstate=disable` will force use of `acpi_cpufreq` instead (sometimes done if `intel_pstate` behaves poorly, but rare).

- **Governors:** Common governors include `performance` (lock at max freq), `powersave` (lock at min freq), `ondemand` (legacy, ramp up on demand), and `schedutil` (modern default, integrates with scheduler to set freq based on CPU utilization). Intel’s and AMD’s P-state drivers have internal governors that approximate `schedutil` behavior (in fact, Intel/AMD P-state in “powersave” mode is akin to schedutil). Tuning governors can be done via `cpupower` utility or through TLP settings. For example, one can echo “schedutil” or “powersave” into `/sys/devices/system/cpu/cpu*/cpufreq/scaling_governor` for each CPU (or use a tool to apply across all). The **impact**: The governor determines how quickly and to what frequency the CPU responds. For best battery life, a combination of a conservative governor and low EPP (energy preference) helps. For instance, on Intel you might set `intel_pstate` to passive and use `schedutil` governor with `ENERGY_PERF_BIAS=15` (maximum energy saving bias). This will make the CPU reluctant to boost unless needed. Conversely, on AC power or when performance is needed, you’d use `performance` governor or EPP=0 (performance bias) to maximize responsiveness. **Switching governors dynamically**: Tools like **TLP** or **auto-cpufreq** handle this – as shown in NixOS, TLP can be configured to use “powersave” on battery and “performance” on AC. Auto-cpufreq is another daemon that adjusts governor based on load and whether on battery.

- **Scheduler Tuneables:** Beyond governors, Linux’s scheduler itself can be tuned for power. The **`sched_allow_idle_remote_wakeup`** and related sysctls, or using CPU affinity to isolate background tasks to specific cores, can help CPUs stay idle. One notable feature is **tickless idle** (CONFIG_NO_HZ_FULL and dynticks): by not having periodic timer interrupts on idle CPUs, those CPUs can stay in deep C-state longer ([Chapter 31. Configuring an operating system to optimize CPU ...](https://docs.redhat.com/en/documentation/red_hat_enterprise_linux/8/html/monitoring_and_managing_system_status_and_performance/configuring-an-operating-system-to-optimize-cpu-utilization_monitoring-and-managing-system-status-and-performance#:~:text=Chapter%2031,allow%20new%20processors%20to)). Most distros already enable tickless kernel (at least in idle). There’s also the **`schedutil`** governor which essentially uses scheduler hints to adjust frequency each tick – it’s generally considered better for efficiency than ondemand. Energy-Aware Scheduling (EAS) is enabled if the kernel is built with energy models (mostly on ARM big.LITTLE) – it tries to minimize energy for a given performance target.

### Kernel Idle Driver and C-States

The Linux kernel uses the **CPUIdle framework** to manage CPU C-states (idle states). Intel systems typically use the **`intel_idle`** driver, which knows about Intel-specific C-states, instead of the generic ACPI idle driver. AMD either uses `intel_idle` (if it supports the CPU) or ACPI. There are a few governors for cpuidle (not to be confused with frequency governors):

- **`ladder` vs `menu` cpuidle governors:** The “menu” governor is the default on most modern kernels; it is sophisticated in predicting idle duration and selecting an appropriate C-state, rather than simply going stepwise deeper ([Improving idle behavior in tickless systems - LWN.net](https://lwn.net/Articles/775618/#:~:text=Improving%20idle%20behavior%20in%20tickless,The%20basic)) ([cpupower-idle-set(1) - Debian Manpages](https://manpages.debian.org/testing/linux-cpupower/cpupower-idle-set.1.en.html#:~:text=cpupower,is%20selected%2C%20the%20menu)). “ladder” was a simpler governor (go deeper one step at a time). There is also a newer “TEO” (Timer Events Oriented) governor introduced to optimize idle state selection ([CPU Idle Time Management - The Linux Kernel Archives](https://www.kernel.org/doc/html/v5.4/admin-guide/pm/cpuidle.html#:~:text=There%20are%20three%20CPUIdle%20governors,the%20kernel%20and%20in)). Generally, you don’t need to manually change these – the default “menu” or “teo” works well. But on some systems (particularly older kernels or specific SoCs) one may experiment with them via kernel config or boot param if needed. 

- **Max C-state controls:** As mentioned, kernel parameters like `intel_idle.max_cstate=N` or `idle=nomwait` for AMD can override behavior. Additionally, `/dev/cpu_dma_latency` is an interface that allows user-space to prevent deep idle by holding the latency requirement open (for audio or low-latency apps). When no such requirement, the CPUidle goes to deepest state. On servers, sometimes admins restrict C-states to avoid latency hits (e.g. setting max C1 or C2 in BIOS), but on a laptop on battery, that would hugely increase idle power consumption ([Can Disabling Hyperthreading Increase Battery Life? - CPUs, Motherboards, and Memory - Linus Tech Tips](https://linustechtips.com/topic/694423-can-disabling-hyperthreading-increase-battery-life/#:~:text=Without%20Hyperthreading%2C%20the%20battery%20discharge,rate%20stayed%20around%2014%20watts)). For instance, an XPS laptop might idle at 3-4W package power if limited to C2, versus 0.5W in C10. Therefore, the kernel defaults should be left unless you have a specific issue like a device misbehaving in deep C-state.

- **Scheduling Tick and Idle:** With *tickless idle*, when a core has no tasks, the scheduler can halt the periodic timer tick, enabling deeper sleep. You can check `/proc/timer_list` or use `powertop` to see if any interrupts are firing regularly. Ideally, on an idle system, each CPU should stay idle until an actual event occurs. **Dynamic ticks** are enabled by default on modern laptop kernels (CONFIG_NO_HZ_IDLE), which is why modern systems can reach deep package C-states routinely.

### PCIe ASPM and Bus Power Management

**Active State Power Management (ASPM)** for PCI Express is a key power-saving feature for I/O devices. It lowers link power when the bus is idle by putting the link in L0s or L1 states. Many BIOSes enable ASPM by default for mobile systems; however, sometimes it’s left off for compatibility. In Linux, you can check ASPM status via `lspci -vv | grep ASPM` which will show if it’s enabled and which state (L0s, L1). If ASPM is disabled by BIOS and you know your hardware supports it, you can force-enable it with the kernel parameter `pcie_aspm=force`. **Caution:** forcing ASPM on unsupported combinations can cause instability, so use only if you’re sure. Another way to influence ASPM is at runtime via `/sys/module/pcie_aspm/parameters/policy`. On some kernels you can echo “powersupersave” to set the most aggressive ASPM policy (L1 substates, etc.). Setting it to “performance” would disable ASPM. The *trade-off* with ASPM is very minor: enabling it can add a bit of latency for PCIe device transactions after idle, but usually in the microsecond range – well worth the power saved. Devices like Wi-Fi, SSD, and GPU can all benefit. In practice, always allow ASPM on battery; only disable if a device has issues resuming.

Other bus power management features include **PCIe Clock Power Management** (CLKPM), **PCIe ASPM L1 Substates (L1.1/L1.2)**, etc., which are usually handled automatically if supported. **PCI runtime power management** is another aspect: Linux can power-down entire PCI devices when not in use (putting them into D3cold state). For example, an unused SD card reader or discrete GPU can often be put into D3 to save power. TLP by default enables PCI runtime PM for devices (it has a list of exceptions). You can manually control it via `/sys/bus/pci/devices/0000:00:xx.x/power/control` (`on` vs `auto`).

Additionally:
- **SATA Link Power Management (ALPM):** By default, SATA link power management might be set to `max_performance`. Using TLP or powertop, you can set it to `min_power` or `med_power_with_dipm` which allows the SATA controller and drive to enter low-power states when idle. This can save 0.5–1W on idle for an SSD/HDD, but may increase latency slightly when the disk is accessed after a pause. TLP’s default config often enables `min_power` on battery.
- **USB Autosuspend:** USB devices can be autosuspended after a period of inactivity. Powertop’s tunables and TLP can enable this globally. By default, many distros set `USB_AUTOSUSPEND=1` on battery (suspend after 1–2 seconds of idle). This can save power especially on devices like USB wireless dongles, webcams, etc., but occasionally causes a lag (e.g. a USB mouse might have a slight delay on first move if it was suspended). TLP allows excluding specific devices from autosuspend if they misbehave.
- **Display and Graphics Power:** Although focused on CPU, it’s worth noting the display panel and GPU often consume more power than the CPU at idle. Enabling Panel Self Refresh (PSR) on Intel iGPUs (usually automatic if supported) can reduce display refresh power. Runtime suspending the discrete GPU (DGPU) when not in use (for hybrid graphics laptops) is crucial – typically achieved with kernel driver parameters (e.g. `nouveau.runpm=1` or vendor driver doing it). The Framework laptop community noted enabling deeper sleep for NVMe (APST – Autonomous Power State Transition) and other components helped achieve sub-10W idles. All these are part of overall power management.

### Tools: TLP, Powertop, and Cpupower

Linux users have a variety of tools to simplify power tuning:

- **TLP:** A popular power management package that applies various tunings out-of-the-box ([TLP - Optimize Linux Laptop Battery Life — TLP 1.8.0 documentation](https://linrunner.de/tlp/index.html#:~:text=documentation%20linrunner,delve%20deeper%20into%20technical%20details)). TLP is essentially a set of scripts and configs; it doesn’t run a heavy daemon, but rather configures kernel settings at startup and on AC/battery events. As per the ArchWiki, it has “sensible defaults for most laptops”. By simply enabling TLP, one gets: CPU governor switching (performance on AC, powersave on battery), USB autosuspend, PCIe ASPM (if not already on), SATA ALPM, audio power save (`snd_hda_intel` power_save=1), Wi-Fi power save, Bluetooth toggle, and battery charge threshold (for some models) among other things. TLP can be configured via `/etc/tlp.conf`. In NixOS, enabling the TLP module (`services.tlp.enable = true`) with optional custom settings as shown yields these benefits declaratively. TLP is very useful for users who want good battery life without micromanaging every sysfs knob. It’s extensively documented by its developer (linrunner). One should be aware not to run TLP concurrently with other tuning daemons like auto-cpufreq or laptop-mode; use one tool to avoid conflicts.

- **PowerTOP:** An Intel-developed tool that reports power usage by component and offers an interactive way to enable power-saving modes ([Running PowerTOP on boot - Alan Doyle](https://alandoyle.com/blog/running-powertop-on-boot/#:~:text=Running%20PowerTOP%20on%20boot%20,a%20computer%27s%20electrical%20power%20consumption)). `powertop` is great for diagnosing what’s using power at idle. Its **“Tunables”** tab suggests settings to improve power (e.g. enabling autosuspend on various devices). Running `powertop --auto-tune` will apply all those suggestions automatically ([[Tip] Use powertop --auto-tune! : r/linux - Reddit](https://www.reddit.com/r/linux/comments/7ebqd8/tip_use_powertop_autotune/#:~:text=powertop%20has%20a%20command,tune)). Many of these overlap with what TLP does (and indeed TLP and powertop can work together – TLP even references powertop suggestions in its docs ([Powertop — TLP 1.8.0 documentation](https://linrunner.de/tlp/faq/powertop.html#:~:text=Powertop%20%E2%80%94%20TLP%201,and%20after%20installation%20of))). Powertop doesn’t persist changes by itself (unless you use a systemd service or rc.local to call `--auto-tune` at boot). It’s primarily a diagnostic tool to find rogue components (for example, if some device is periodically waking the CPU, powertop can show a high “wakeups per second” count for that interrupt). Using powertop, one can iteratively tweak settings until the system reaches a low idle power.

- **cpupower / cpufreqctl:** The `cpupower` command (part of Linux utility package) allows setting governors, frequencies, and querying info. Example: `cpupower frequency-info` will list available drivers and freq range. `cpupower frequency-set -g powersave` sets the governor. It’s essentially a command-line interface to CPUfreq settings, and can be used in scripts or manually. On some distros, there’s also a GUI (like cpupower-gui) to simplify this. In NixOS, one might not use cpupower directly but rather configure through NixOS options or let TLP handle it. However, NixOS does support a `powerManagement.cpupower` module for setting a default governor via systemd service if desired.

- **Laptop Mode Tools:** Another older tool (not as popular now due to TLP) is **Laptop Mode Tools** (LMT). It can also manage many power settings (spinning down disks, etc.). It introduced the concept of **“Laptop mode”** for disk I/O – essentially increasing dirty writeback timings to allow disk to stay spun down longer. In modern SSD-based laptops this is less relevant, but for HDDs it was important. LMT can conflict with TLP, so typically one uses one or the other. TLP is more straightforward and is widely favored now.

- **Auto-cpufreq:** A newer tool that focuses on dynamically adjusting CPU frequency in response to load and whether on battery. It’s less comprehensive than TLP, but some prefer its approach to CPU scaling (it can, for example, detect when you’re on battery but actively typing on AC, etc., and adjust frequencies accordingly). NixOS has a module for it (`services.auto-cpufreq.enable`). TLP and auto-cpufreq can technically run together (NixOS allows it) but that’s generally not recommended as they both tweak CPU governor. It’s best to choose one strategy.

- **Vendor-Specific Tools:** On some systems, manufacturer-specific drivers or daemons exist (for example, Lenovo’s `acpi_call` module can be used to disable dGPU or set charge thresholds; Dell has `idrac` on servers, etc., and Intel’s thermald which helps prevent overheating by adjusting CPU as well). **Thermald** is worth mentioning for Intel: it’s a daemon (`services.thermald` on NixOS) that monitors thermal sensors and enforces cooling policies (by lowering boost or engaging cooling). It doesn’t directly save power, but by preventing severe throttling it can maintain efficiency (e.g. stop the CPU from hitting thermal limits where it operates inefficiently). It’s mostly about safety and performance consistency.

### Kernel Module Configuration (NixOS and General Linux)

Many power-related features are enabled via kernel module parameters. In NixOS, you can set these via `boot.kernelModules` and `boot.kernelModuleConfig` or through NixOS options if available. On other distros, one typically creates a config in `/etc/modprobe.d/`. Some important ones:

- **Intel Wi-Fi (iwlwifi) power save:** As cited in ArchWiki, adding `options iwlwifi power_save=1` enables Wi-Fi power saving (which can increase latency slightly, and there are additional parameters like uapsd for Unscheduled Power Save Delivery to save more power at cost of latency). NixOS can set this by: `hardware.network.wireless.iwlwifi.enablePowerSave = true;` (if such an option exists) or via `boot.extraModprobeConfig`. The ArchWiki also mentions `iwlwifi d0i3_disable=0` for older kernels to enable a deep sleep state on some Intel WiFi NICs. The **trade-off** for WiFi power save is minor: slightly higher ping times or a momentary delay in network traffic after idle.

- **Sound power saving:** Many Intel HD Audio codecs support a power-save mode that powers down the audio codec after a few seconds of no use. TLP sets `snd_hda_intel` module parameter `power_save=1` and `power_save_controller=Y` by default, which can save ~0.4W when audio is not playing. This can be set in NixOS via something like `hardware.pulseaudio.powerSaveTime = 1;` or directly adding an option for the module.

- **Bluetooth:** If you’re not using Bluetooth, turning it off entirely (rfkill or unloading the module) saves power. Some distros keep the BT radio on. TLP can toggle it off on startup if you set `DEVICES_TO_DISABLE_ON_STARTUP="bluetooth"`.

- **NVIDIA/AMD dGPU power:** For hybrid graphics, loading the driver with runtime PM support (e.g. `nvidia` proprietary driver has its own methods, `amdgpu` has `amdgpu.runpm=1` by default on laptops to auto-suspend the GPU). If using open-source drivers, the kernel parameter `radeon.power_profile=low` could be used on older AMD GPUs, etc. These are highly device-specific but critical for those devices.

- **Custom ACPI Tables:** On Linux, one can override ACPI DSDT by adding an initrd image (`initrd=/acpi_override` in grub with a custom table). This is an expert move – for example, fixing an ACPI bug where a device doesn’t suspend or adding missing _DSM methods to control fan or VRM. In context of power, a known hack was overriding ACPI to enable ASPM when OEM disabled it. Another example: some laptops had broken _PS3 (power down) methods for PCI devices; users provided corrected DSDTs. This is truly “deep” tuning – ideally the community (forums like NotebookReview or kernel mailing list) will have a ready DSDT patch if it’s a common model issue. Otherwise, doing this requires ACPI knowledge. There are also **ACPI call** interfaces (like using the `acpi_call` kernel module to call ACPI methods at runtime) – for instance, turning off a discrete GPU (Dell/Lenovo had ACPI calls to cut power to GPU). This is sometimes the only way if the standard drivers don’t handle it. NixOS users can include custom ACPI tables by building a custom kernel or using the `boot.extraInitrd` to include the table – but details are complex.

- **Dynamic Device Tree Overlays:** On ARM devices, you might use configfs to load Device Tree Overlays at runtime (if supported) to disable or change hardware configuration. For example, on a Raspberry Pi, one could unload the DT fragment that enables HDMI to save power when HDMI output isn’t needed. Or disable a sensor. Raspberry Pi forums mention potential future support for dynamic overlays (instead of requiring reboot) ([STICKY: Optional interfaces (I2C, I2S, SPI) and Device Tree](https://forums.raspberrypi.com/viewtopic.php?t=98318#:~:text=Tree%20forums,but%20that%20is%20some)). In general, on laptops (x86) this isn’t applicable because ACPI, not DT, is used. On ARM laptops, you have to do such changes before boot or compile into the DTB. So dynamic DT manipulation remains an edge topic – relevant mostly in embedded cases.

### Memory (RAM) Configuration and Power

Memory can contribute to overall power draw, especially as capacities increase. Key considerations:

- **LPDDR vs DDR:** Low-Power DDR (LPDDR) memory is common in ultraportables and phones. LPDDR operates at a lower voltage and has deep power-saving modes, significantly reducing memory power usage. For example, LPDDR4 can save up to ~40% power compared to standard DDR4 at equivalent tasks. LPDDR also supports features like partial array self-refresh (only refreshing needed parts of memory) and finer-grained power-down of I/O. A Hacker News discussion noted that premium laptops have moved to LPDDR not just for form factor but for energy: LPDDR can bring active power per GB under 1W, which is much lower than socketed DIMMs. The downside of LPDDR is it’s soldered (no upgrade) and sometimes slightly higher latency. But from a power perspective, LPDDR is superior. Apple’s M1 uses customized memory packages that consume under 1W even under load – enabling their 20-hour battery life feats. So, the type of memory heavily influences the baseline power: an older laptop with DDR3 modules might use a couple watts more than a similar one with LPDDR4X.

- **Capacity and Number of Sticks:** More RAM = more chips to keep refreshed. DRAM must refresh its cells periodically (even when not actively used), drawing power. An interesting finding from the Framework Laptop community: going from 8 GB to 48 GB (i.e., more and higher density chips) led to a *10× increase* in self-refresh power consumption ([Impact of RAM density on suspend power consumption - Linux - Framework Community](https://community.frame.work/t/impact-of-ram-density-on-suspend-power-consumption/57664#:~:text=A%2010x%20difference%20in%20power,and%20not%2010x)). That was higher than expected linear scaling, possibly due to different DDR5 module designs. In S3 suspend (RAM self-refresh), each RAM module could draw on the order of tens of milliwatts to a few hundred milliwatts. If a 8GB module draws, say, 0.05 W in self-refresh, a 32GB might draw 0.15 W, and two of them 0.30 W. This directly cuts into standby time (e.g., a laptop with 64GB might drain notably faster in sleep than one with 16GB). Even during normal use, having more sticks/chips increases idle power slightly. A Superuser post noted laptop memory uses “less than 3 W per stick” under active use, which is small compared to CPU/GPU, but at idle it should be much lower, perhaps 0.5–1 W per stick depending on size. If you can remove or disable RAM that you don’t need, you could save some power – though most laptops can’t dynamically disable a RAM channel on the fly. In BIOS, some let you limit memory (for testing) which effectively powers down a portion, but that’s niche.

- **Frequency/Timing of RAM:** Running RAM at a lower data rate or in a lower power mode can save energy. For instance, using DDR4-2133 instead of DDR4-3200 on a laptop will reduce the memory interface power a bit (and maybe allow lower voltage if the higher speed required 1.35V vs 1.2V). One Reddit discussion calculated an overclocked DDR4 at 1.35V could consume ~3.25 W per module under load ([2400Mhz vs 3200Mhz DDR4 - is the power consumption difference ...](https://www.reddit.com/r/DataHoarder/comments/15xa8pb/2400mhz_vs_3200mhz_ddr4_is_the_power_consumption/#:~:text=2400Mhz%20vs%203200Mhz%20DDR4%20,Those%20are%20averages%2C%20depending)). At idle, the difference between 2133 and 3200 might not be huge since refresh dominates idle power rather than active switching. However, some memory controllers can downclock memory during deep C-states or in low-power S0ix states. Intel’s “Self-Refresh Boost” (on Tiger Lake etc.) can drop memory frequency when the display is off. There’s also the concept of **gear modes** (Gear 2 runs memory controller at half rate to save power at cost of latency) on newer Intel – some laptops use Gear 2 for power reasons.

- **Disabling Unused Memory Banks:** In systems with ECC or large memory, sometimes not all ranks are needed. On certain servers, you can offline pages of memory in the OS (memory hotplug) and then potentially put a RAM stick in self-refresh isolate (not typically done on laptops). On a few enthusiast systems, people physically remove extra RAM for slightly better battery. Realistically, on most laptops, you’ll use whatever memory is installed. But if you have a choice, using a single stick (single channel) instead of two will save a bit of power (half the chips to refresh). The trade-off is lower memory bandwidth and performance (especially if an integrated GPU shares RAM, it will halve GPU mem bandwidth).

- **RAM vs CPU trade-offs (Offloading tasks to RAM):** The idea of “CPU task offloading to RAM” is a bit of a misnomer – RAM cannot execute tasks, but keeping more things in memory can offload work from the disk and reduce CPU waiting. Essentially, **using RAM as cache** improves efficiency: the CPU can quickly fetch data from RAM rather than doing a slow disk I/O (which would involve CPU time handling interrupts, waiting on I/O, possibly spinning disk). The SuperUser discussion concluded that *more memory usage is generally not a big battery drain, and actually can improve overall efficiency by reducing disk access*. The CPU might actually do *more* work if more RAM is available (since it can feed more data or run bigger tasks), but that work is useful (improving performance). If a system is RAM-starved and swapping, the CPU spends a lot of time compressing memory or orchestrating swap I/O – which is inefficient. So having sufficient RAM is important for power too. There’s not a direct mechanism to “offload CPU computations to RAM” (RAM is passive), but there are techniques like using DMA engines or intelligent controllers that can move data around without CPU involvement. For example, NVMe controllers can do data transfer and even encryption with minimal CPU. That’s more offloading to devices than to RAM, though.

- **Memory Power Down Modes:** DDR4/5 has modes like power-down (where some clock nets are gated when idle) and self-refresh (used in deep idle). Ensuring those are utilized is mostly up to BIOS/firmware. On Linux, when the system enters S3 (suspend to RAM), the memory is in self-refresh. In active use, there’s not much the OS can do except try to keep memory usage such that some ranks could possibly power-down. Some research (like the Usenix paper referenced in the StackExchange post) show DRAM energy management techniques, but those are beyond standard OS control. 

In practice, the best a user can do regarding RAM is:
- Prefer LPDDR if battery life is a priority (though that’s decided at purchase time).
- Don’t wildly over-provision RAM if you don’t need it (e.g., 64GB in a laptop that only ever uses 8GB could be wasting a bit of power just refreshing unused cells).
- Use RAM-heavy techniques to reduce CPU or disk work where possible (e.g., cache files in tmpfs if it prevents spinning up a disk, use zram for swap to avoid disk I/O – though zram uses CPU for compression, it’s a trade-off between CPU cycles and disk power).
- Keep memory channels filled appropriately; sometimes running in dual-channel is more power-efficient per work done (because tasks finish faster, letting CPU idle more), even if it has slightly higher absolute power than single-channel. So there’s a balance between performance and energy: faster memory can save time in active state, thus more idle time – this is the classic **race-to-idle** concept.

## Kernel-Level Experimental Patches and Cutting-Edge Tweaks

For completeness, there are experimental and niche kernel patches aimed at power saving:
- **Intel “PCU idle injection”**: Patches that cause the scheduler to deliberately insert idle periods to keep power within limits or to improve efficiency (used in ChromeOS for power capping).
- **Intel RAPL and power capping:** One can set power limits via RAPL interfaces (`/sys/class/powercap/intel-rapl`), essentially telling the CPU to cap to a certain wattage (similar to setting TDP). This is not a patch but an interface; tweaking it can throttle CPU to save power.
- **PHC Kernel Patch:** An old patch called Processor Hardware Control (PHC) allowed undervolting Intel Core CPUs before official interfaces existed. This is largely obsolete now.
- **Scheduling and QoS patches:** e.g., the **PowerQoS** concept – allowing certain tasks to indicate they prefer to save power or prefer performance, and scheduler would act accordingly. Some of this is in mainline (see cgroups power policies, or using nice levels to indirectly affect CPU frequency).
- **ACPI and Platform Firmware**: Some laptop firmwares expose advanced settings (via ACPI WMI or debug interfaces) to control behaviors like “silent mode”, “low power S0 idle”. Reverse-engineering those (through ACPI WMI calls or Embedded Controller commands) can sometimes allow users to toggle power modes not otherwise accessible. The Linux community (on forums or GitHub) sometimes creates tools for specific models (for instance, `lenovo-battery` or `asus-fan-control` etc.) that can set these modes.

- **Community Resources:** It’s worth keeping an eye on forums like Arch Linux Forums, Reddit (e.g. r/LinuxHardware), or kernel mailing lists for specific tweaks. For example, Framework Laptop owners experimented with BIOS settings and Linux kernel parameters to reduce idle drain. ThinkPad enthusiasts often share tips about undervolting or using ecfw (embedded controller firmware) to change behavior.

Finally, **NixOS specific:** NixOS, being declarative, lets you compile all these into one configuration. For instance, you could have something like:

```nix
{ 
  powerManagement.enable = true;
  services.tlp.enable = true;
  services.tlp.settings = {
    CPU_SCALING_GOVERNOR_ON_BAT = "powersave";
    CPU_ENERGY_PERF_POLICY_ON_BAT = "power";
    CPU_MAX_PERF_ON_BAT = 50;
    SCHED_POWERSAVE_ON_BAT = 1;
    SOUND_POWER_SAVE_ON_BAT = 1;
    ...etc...
  };
}
```

This would bake in many of the discussed optimizations. Additionally, `hardware.cpu.intel.updateMicrocode` (for Intel) or AMD equivalent should be enabled to get the latest CPU microcode, which sometimes contains power-related fixes. NixOS can also use **specializations** to create a “battery-optimized” boot entry that perhaps even disables the dGPU entirely and uses a different kernel config (as shown in the NixOS wiki for hybrid graphics).

## Conclusion

Advanced power management on laptops is a multi-layered challenge – from hardware capabilities (CPU SMT, frequency/voltage scaling, RAM type) to kernel subsystems (cpufreq, cpuidle, ACPI, device runtime PM) to user-space tools (TLP, powertop). Intel, AMD, and ARM CPUs each offer unique features, but the fundamental strategies overlap: **eliminate wasted work, use the lowest necessary performance state, and leverage deep sleep as much as possible**. 

Disabling features like hyper-threading or unused cores can save power but usually with a direct performance cost, so those are only justified in specific scenarios. Undervolting is a big win where available, improving efficiency outright. Frequency governors and power limits let users dial in their preferred balance (e.g. longest battery vs. acceptable speed). And at the system level, Linux provides numerous hooks – from ASPM for I/O to autosuspend of devices – that can cumulatively make a significant difference (several watts cut from idle usage, which on a ~50 Wh battery translates to hours more runtime).

For system developers and power users, the key is to measure and iterate: tools like powertop help identify which component to tune next. Community documentation (ArchWiki’s power management guides, kernel docs, forums) is invaluable for discovering less obvious tweaks (like modprobing a driver with a power_save option). With careful application of these strategies, one can achieve impressive power savings on Linux laptops – sometimes even rivaling or exceeding the efficiency of the stock OS provided by the manufacturer – while still retaining the performance needed when plugged in or when really demanded.

**Sources:**

- Arch Linux Wiki – *CPU Frequency Scaling*, *Power Saving*, *Laptop* (power management)  
- Linus Tech Tips forum – user test on Hyper-Threading vs power draw ([Can Disabling Hyperthreading Increase Battery Life? - CPUs, Motherboards, and Memory - Linus Tech Tips](https://linustechtips.com/topic/694423-can-disabling-hyperthreading-increase-battery-life/#:~:text=While%20running%20Cinebench%3A))  
- Acer Community (AMD SMT discussion by StevenGen) ([HOW TO ENABLE BIOS ADVANCED SETTINGS ON NITRO 5 AN515-44? — Acer Community](https://community.acer.com/en/discussion/676399/how-to-enable-bios-advanced-settings-on-nitro-5-an515-44#:~:text=Consumption))  
- KingDian Tech Blog – *Low-Power Laptop Memory (LPDDR vs DDR)*  
- SuperUser – Q&A on RAM and battery usage  
- Framework Community – discussion on RAM capacity vs power in suspend ([Impact of RAM density on suspend power consumption - Linux - Framework Community](https://community.frame.work/t/impact-of-ram-density-on-suspend-power-consumption/57664#:~:text=A%2010x%20difference%20in%20power,and%20not%2010x))  
- ArchWiki – *Undervolting CPU* (via ArchWiki quote/Gist) ([Linux Laptop Optimizations  · GitHub](https://gist.github.com/LarryIsBetter/218fda4358565c431ba0e831665af3d1?permalink_comment_id=4739484#:~:text=%2A%20From%20Arch%20Wiki%20,I%27ll%20leave%20a%20link%20to)) ([Linux Laptop Optimizations  · GitHub](https://gist.github.com/LarryIsBetter/218fda4358565c431ba0e831665af3d1?permalink_comment_id=4739484#:~:text=Note%20that%20most%20desktop%20motherboards,to%20undervolt%20your%20AMD%20CPU))  
- NixOS Wiki – *Laptop Power Management (TLP, auto-cpufreq, etc.)*  
- ArchWiki – *Active State Power Management (ASPM)*  
- Reddit & StackExchange – various discussions on CPU offloading and buffer sizes (for understanding CPU vs RAM interplay) ([Why does increasing buffer size decrease CPU consumption? : r/audioengineering](https://www.reddit.com/r/audioengineering/comments/mx56b8/why_does_increasing_buffer_size_decrease_cpu/#:~:text=CPUs%20are%20much%20faster%20when,each%20individual%20chunk%20of%20work)).

